# -*- coding: utf-8 -*-
"""Aula_Doutorado_IA_comentado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c3SFg3QFOMI-T3zmRG_1YMGhcDbWZ5Cj

# <span style="color:blue">Python para cientistas</span>

## <span style="color:blue">Ajuste dados experimentais por regress√£o linear</span>
---

***Problema***


Vamos considerar o problema da determina√ß√£o da constante de Planck h, a partir de dados obtidos
numa experi√™ncia com uma c√©lula fotoel√©trica, que consistem numa s√©rie de valores do potencial de
paragem $ùëâ_ùëù$, em fun√ß√£o do comprimento de onda da luz incidente na c√©lula.

Utilizando a lei de Planck:

$$
E = h √ó ŒΩ
$$

em que $E$ √© a energia de um foton e $\nu$
a sua frequ√™ncia, e a lei de conserva√ß√£o da energia pode
escrever-se:

$$
ùëíùëâ_ùëù = ‚ÑéŒΩ ‚àí W
$$

$$
y = mx + b
$$

em que $ùëä$ √© a energia de arranque da c√©lula, considerada constante para cada c√©lula.  A partir da sua equa√ß√£o, Einstein fez a seguinte previs√£o: variando-se a freq√º√™ncia, $ŒΩ$, da luz incidente e plotando-se $V_p$ versus $\nu$, obt√™m-se uma reta, cujo coeficiente angular deve ser $h$, sendo $h$ uma constante universal, independente do material irradiado. Esta constante √© conhecida como constante de Planck, determinada pela lei de radia√ß√£o.

**O problema consiste, portanto, em:** dados $(ùëâ_{ùëù,ùëò}, ùúà_ùëò)(ùëò = 1,2, ‚Ä¶ , ùëÅ)$, calcular a melhor aproxima√ß√£o
poss√≠vel (num sentido a definir) para $‚Ñé$. A solu√ß√£o do problema fornecer√° igualmente um valor para
$ùëä$.
"""

# ------------------
# IA: Previs√£o com Regress√£o Linear (Machine Learning)
# ------------------
# Neste bloco, ao inv√©s de usar apenas o modelo f√≠sico para ajuste,
# aplicamos um algoritmo de IA (Machine Learning) - Regress√£o Linear -
# para aprender a rela√ß√£o entre a frequ√™ncia (ŒΩ) e o potencial de parada (Vp)
# a partir dos dados experimentais, e ent√£o prever novos valores.

from sklearn.linear_model import LinearRegression
import numpy as np

# Dados experimentais
# Frequ√™ncia da luz incidente (ŒΩ) em Hz
# Potencial de parada (Vp) em Volts
# Obs: Valores fict√≠cios apenas para exemplifica√ß√£o
nu = np.array([5.0e14, 5.5e14, 6.0e14, 6.5e14, 7.0e14]).reshape(-1, 1)  # Vari√°vel independente
Vp = np.array([0.5, 0.9, 1.3, 1.6, 2.0])  # Vari√°vel dependente

# Criando o modelo de Machine Learning
# A regress√£o linear vai ajustar Vp = m * ŒΩ + b sem depender explicitamente da equa√ß√£o f√≠sica.
model = LinearRegression()

# "Treinando" o modelo com os dados experimentais
model.fit(nu, Vp)

# Definindo novas frequ√™ncias para prever o potencial de parada
novas_frequencias = np.array([[7.5e14], [8.0e14]])

# Usando o modelo treinado para prever Vp para as novas frequ√™ncias
Vp_previsto_ml = model.predict(novas_frequencias)

# Exibindo resultados das previs√µes
for freq, vp in zip(novas_frequencias.flatten(), Vp_previsto_ml):
    print(f"Frequ√™ncia: {freq:.2e} Hz -> Vp previsto (IA/ML): {vp:.3f} V")

# ------------------
# Visualiza√ß√£o gr√°fica
# ------------------
import matplotlib.pyplot as plt

# Pontos originais do experimento
plt.scatter(nu, Vp, color='blue', label='Dados experimentais')

# Linha de ajuste obtida pelo modelo de IA (ML)
plt.plot(nu, model.predict(nu), color='red', label='Ajuste IA (ML)')

# Pontos de previs√£o para novas frequ√™ncias
plt.scatter(novas_frequencias, Vp_previsto_ml, color='green', label='Previs√µes IA')

# Configura√ß√µes do gr√°fico
plt.xlabel('Frequ√™ncia (Hz)')
plt.ylabel('Potencial de parada (V)')
plt.title('Ajuste e Previs√£o por IA (Regress√£o Linear - ML)')
plt.legend()
plt.grid(True)
plt.show()
